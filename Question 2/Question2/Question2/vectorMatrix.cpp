#include "stdafx.h"
#include "vectorMatrix.h"
#include <algorithm>    // std::sort

vectorMatrix::vectorMatrix(int x, int y)
{
	matrix = vector<vector<int>>(y, vector<int>(x)); //flip the axes since the first dimension coveres number of rows not columns

	//use iterators to go through each element of the matrix and assign them a random value generated by rand - only pseudorandom sadly
	vector< vector<int> >::iterator row;
	vector<int>::iterator col;
	for (row = matrix.begin(); row != matrix.end(); row++) 
	{
		for (col = row->begin(); col != row->end(); col++)
		{
			int random = 0;
			random = (rand());
			*col = random;
		}
	}
}

vectorMatrix::~vectorMatrix()
{
	//destructor stuff
}

void vectorMatrix::reorderMatrix()
{
	cout << " \n Rearranging the Matrix now. \n";
	int lowestSoFar = INT_MAX;
	int currentRow = NULL;
	int currentCol = NULL;
	int totalRow = NULL;
	int totalCol = NULL;

	//grab the total columns and rows for the matrix
	totalCol = matrix[0].size();
	totalRow = matrix.size();

	//creat one that wil be used to store the values during sorting - but make it the opposite dimensions to the original one
	vectorMatrix transferMatrix = vectorMatrix(totalRow, totalCol);

	vector< vector<int> >::iterator row;
	vector<int>::iterator col;
	//use the iterators once again to iterate through the matrix  only this time insert each value into the transfer matrix
	//this method creates the same matrix but rotated on its side - all rows become columns and columns become rows
	for (row = matrix.begin(); row != matrix.end(); row++)
	{
		currentRow = std::distance(matrix.begin(), row); //use the iterator and distance methods to get the current column and rows that we are in when we need them

		for (col = row->begin(); col != row->end(); col++)
		{
			currentCol = std::distance(row->begin(), col);
			transferMatrix.matrix[currentCol][currentRow] = matrix[currentRow][currentCol];
		}
	}

	vector< vector<int> >::iterator rowTransfer;
	vector<int>::iterator colTransfer;
	int currentRowTransfer = 0;
	//again use iterators to go through - but this time we only need to iterate through the rows of the transfer matrix - on top of that
	// c++ has a built in std::sort which sorts in order from lowest to highest - just like i want - so call this for each row
	for (rowTransfer = transferMatrix.matrix.begin(); rowTransfer != transferMatrix.matrix.end(); rowTransfer++)
	{
		currentRowTransfer = std::distance(transferMatrix.matrix.begin(), rowTransfer);
		std::sort(transferMatrix.matrix[currentRowTransfer].begin(), transferMatrix.matrix[currentRowTransfer].end());
	}

	vector< vector<int> >::iterator rowFinal;
	vector<int>::iterator colFinal;
	//now that the rows in the transfer are all sorted - use iterators once again to rotate them back around to being normal way
	//could probably have just reused iterators and reset them to be more efficient
	for (rowFinal = transferMatrix.matrix.begin(); rowFinal != transferMatrix.matrix.end(); rowFinal++)
	{
		currentRow = std::distance(transferMatrix.matrix.begin(), rowFinal);

		for (colFinal = rowFinal->begin(); colFinal != rowFinal->end(); colFinal++)
		{
			currentCol = std::distance(rowFinal->begin(), colFinal);
			//transferMatrix.matrix[currentCol][currentRow] = matrix[currentRow][currentCol];
			matrix[currentCol][currentRow] = transferMatrix.matrix[currentRow][currentCol];
		}
	}

	//cout << "printing transfer matrix \n"; debug uses
	//transferMatrix.printMatrix();
	cout << " \n printing sorted matrix \n";
	printMatrix();

}

void vectorMatrix::printMatrix()
{
	//go through each element of the matrix using iterators once again and this time "cout" each of the elements
	vector< vector<int> >::iterator row;
	vector<int>::iterator col;
	for (row = matrix.begin(); row != matrix.end(); row++)
	{
		for (col = row->begin(); col != row->end(); col++)
		{
			cout << std::to_string(*col) << "__";
		}

		cout << "\n";
	}

	cout << "\n ";
}